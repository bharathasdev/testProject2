/**
* This is a doc comment for a file
*/
console.log("Display Object");


import Stage from '../graphics/Stage';
import Utils from '../utils/Utils';
import Resizer from '../utils/Resizer';
import Listener from '../events/Listener'

import BrowserEvents from '../events/BowserEvents';

    
/**
 * This is the base class that is responsible to render on screen must be a DisplayObject.
 * This class acts as a base class for every visual memeber that appears on the stage.
 */



export default class DisplayObject{

    protected stage = Stage.getStage();
    protected x:number = 0;
    protected y:number = 0;
    /** The width property sets the width for the DisplayObject. 
     * If the width is not provided then the display object will not be rendered visually. 
     * But still exists as a container in the display list */
    protected width:number = 0;
    /** The height property sets the height for the DisplayObject */
    protected height:number = 0;
    /** The alpha property sets the alpha to the displayObject. setting the value to 0 make the object inivisible and 1 will be visible with full strength. The values can be between 0 to 1. */
    protected alpha:number = 1;  
    /** The node property will hold the core native PIXI object init based on the type of object. */
    protected node:any = null;
    /** The initData property is a object with a bundle of properties and values required to create a DispalyObject. This object will hold all the basic properties required to create an Object  */
    protected initData:object = null;
    /** The drawStroke property determines whether to draw the stroke or not. If set to true the stroke will be drawn. The default value is false */
    protected drawStroke = false;
    /** This enables to draw the Fill for the display object. If set to true the fill will be drawn. The default value is true */
    protected drawFill = true;
    /** The fillColor property is describes the color of a shape. This is required to draw the basic shapes(like rectangle, Square and Circle) with in a display Object. */
    protected fillColor = "0xffffff";
    /** The strokeColor property is describes the stroke color of a shape. This is required to draw the basic shapes with in a display Object. */
    protected strokeColor = "0x000000";
    /** The strokeStyle property is describes the style of the stroke */
    protected strokeStyle:number = 1;
    /** The strokeWidth property is describes the thickness of the stroke */
    protected strokeWidth:number = 1;
    /** The circleRadius property is describes the radius of the circle  */
    protected circleRadius:number = 0;
    /** The PIXITicker property holds the reference to Native PIXI TIcker object from PIXI JS  */
    protected PIXITicker = null;
    /** The id property hold the unique name of the Displayobject. If not provided through initData then id will be autogenerated  */
    protected id:string = null;
    /** The scaleX property controls X-axis  scaling of a DisplayObject */
    protected scaleX:number = 1;
    /** The scaleY property controls Y-axis  scaling of a DisplayObject */
    protected scaleY:number = 1;
    /** The allowClick property makes the object clickable and interactive. This has to be to true to handle any click and tap events */
    protected allowClick:boolean = false;
    /** The clickCallBack property is a click handler which will get triggerred in the event of click or tap. The callback function generally will be in the form of arrow function */
    protected clickCallBack = null;

    protected visibility:boolean = true;
    protected anchor:Array = [0 , 0];
    protected pivot:string = "TOPLEFT";
    protected rotation:number = 0;


    /**
   * Constructor method you can pass an initData object with properties {"x":12, "y":15}  
   * @param initData object with properties if not passed then the object with be created at x and y of 0, 0 respctively.
   *  
   * Usage:
   * 
   * ```typescript
   *  let dataObj = {"x":12, "y":15};
   *  const myDP = new DisplayObject(dataObj);
   *  
   * ```
   */
    constructor(initData:object = {"x":0, "y":0})
    {
        
        this.PIXITicker = PIXI.ticker.shared;

        var that  = this;
        this.initData = initData;
        /*
        this.PIXITicker.add(function(time){

            if(Resizer.ORIENTATION_CHANGED)
            {

                console.log("Heloo:"+time);
                Resizer.ORIENTATION_CHANGED = false; // I know its a bad idea. but will be used till we create our my own Event Listeners
                // Do something

                this.onOrientationChange();
            }
            
        });*/
    
        
    }

    
    /**
    * @ignore
    */
    private valid(initData:object):boolean
    {
        // this will validate the init data and return true or false
        // before creating an object
        return true; 
    }


   /**
   * This can be used to validate the inputdata(initData) in future. 
   * Currently there is no implementation, if needed then it can be implemented later
   * @param initData absolute path of the file to create
   * @return a boolean value of true or false. If the input data is valid then it return true else 
   * it will fail and object creation will be failed or it might not work as expected
   * 
   * Usage:
   * 
   * ```
   * <bharath>hellooo kjdfskjf jdfji</Bharath>
   * ```
   * ```typescript
   * 
   *  const myDP = new DisplayObject(); 
   * ```
   */
    public init()
    {

        
        this.x = Utils.checkNullUndefined(this.initData.x, this.x); 
        this.y = Utils.checkNullUndefined(this.initData.y, this.y); 

        this.alpha = Utils.checkNullUndefined(this.initData.alpha, this.alpha); 
       
        

        this.drawStroke = Utils.checkNullUndefined(this.initData.drawStroke, this.drawStroke);
        this.drawFill = Utils.checkNullUndefined(this.initData.drawFill, this.drawFill);
        this.fillColor = Utils.checkNullUndefined(this.initData.fillColor, this.fillColor);
        this.strokeColor = Utils.checkNullUndefined(this.initData.strokeColor, this.strokeColor);
        this.strokeStyle = Utils.checkNullUndefined(this.initData.strokeStyle, this.strokeStyle);
        this.strokeWidth = Utils.checkNullUndefined(this.initData.strokeWidth, this.strokeWidth);
        this.circleRadius = Utils.checkNullUndefined(this.initData.circleRadius, this.circleRadius);

        this.scaleX = Utils.checkNullUndefined(this.initData.scaleX, this.scaleX);
        this.scaleY = Utils.checkNullUndefined(this.initData.scaleY, this.scaleY);
        this.allowClick = Utils.checkNullUndefined(this.initData.allowClick, this.allowClick);

        this.anchor = Utils.checkNullUndefined(this.initData.anchor, this.anchor);
        this.pivot = Utils.checkNullUndefined(this.initData.pivot, this.pivot);

        this.clickCallBack = Utils.checkNullUndefined(this.initData.clickCallBack, this.clickCallBack);

        this.visibility = Utils.checkNullUndefined(this.initData.visible, this.visibility);

        this.rotation = Utils.checkNullUndefined(this.initData.rotation, this.rotation);

        if(this.valid(this.initData))
        {
            
            this.id = this.initData.type+"_"+ Utils.checkNullUndefined(this.initData.id, Utils.generateAutoID());

            Listener.addEventListener(BrowserEvents.ORIENTATION_CHANGE_TO_LANDSCAPE, ()=>{this.onOrientationChange(this)});
            Listener.addEventListener(BrowserEvents.ORIENTATION_CHANGE_TO_PORTRAIT, ()=>{this.onOrientationChange(this)});

            console.log("Display Object ID:"+this.id);
            if(this.initData.lom)
            {
                console.log("layaout data available");
            }

            
        }
   
        //this.node = new PIXI.Sprite();

        this.node = new PIXI.Container();
        
        if(this.circleRadius > 0)
        {
            this.node.addChild(this.drawCircle());
            
        }
        else if(this.initData.width > 0  && this.initData.height > 0 && this.initData.type !== "ImageDisplay")
        {

            this.node.width = this.initData.width;
            this.node.height = this.initData.height;
            this.width = this.initData.width;
            this.height = this.initData.height;
            this.node.addChild(this.drawGraphics());
        }
        else if(this.initData.type === "TextDisplay")
        {
            // do nothing for now
        }
        else
        {
            //this.node.addChild(new PIXI.Sprite());
        }

        // apply Basic properties for an object

        this.node.name = this.id;
       
        this.setupBasicProperties();
        
        //this.stage.addChild(this.node);
    }

    private setupBasicProperties()
    {
        this.setXY(this.x, this.y);
        this.setAlpha(this.alpha);
        this.setScale(this.scaleX, this.scaleY);
        if(this.visibility)
        {
            this.show();
        }
        else
        {
            this.hide();
        }

        this.setPivot(this.pivot);
        this.setRotation(this.rotation);
        /*
        if(this.anchor[1] !== undefined)
        {
            this.setAnchor(this.anchor[0], this.anchor[1]);
        }
        else
        {
            this.setAnchor(this.anchor[0]);
        }*/
        
        this.clickable(this.allowClick);
        this.setupEvents();
    }


    /**
    * Internal method which setup the click/Tap callback for the DisplayObject's core node object
    */
    protected setupEvents()
    {
        if(this.clickCallBack)
        {
            this.node.on('click', this.clickCallBack);
        }
        
    }


    
    /**
    * Internal method which setup the click/Tap callback for the DisplayObject's core node object
    */
   public setClickCallback(pCallback)
   {
       this.clickCallBack = pCallback;
       this.node.on('click', pCallback);
   }

    /**
    * Internal method which draws the graphics. Make sure drawFill property is set to true to draw any graphics 
    */
    
    private drawGraphics()
    {
        var graphics =  new PIXI.Graphics();

        
        if(this.drawFill)
        {
            if(this.drawStroke)
            {
                graphics.lineStyle(this.strokeWidth, this.strokeColor, this.strokeStyle);
            }
            graphics.beginFill(this.fillColor);
            graphics.drawRect(this.x, this.y, this.width, this.height);
            graphics.endFill();

            this.node.width = this.width;
            this.node.height = this.height;
        }

        return graphics;
        
    }

    /**
    * Internal method which draws the circle. Make sure drawFill property is set to true to draw any graphics 
    */
    private drawCircle()
    {
        this.node = new PIXI.Graphics();

         // Circle + line style 1
        //this.node.lineStyle(2, 0xFEEB77, 1);
        //this.node.beginFill(0x650A5A, 1);
        //this.node.drawCircle(250, 250, 50);
        //this.node.endFill();

        
        if(this.drawStroke)
        {
            //this.strokeWidth = 5;
            //this.strokeStyle = 3;
            this.node.lineStyle(this.strokeWidth, this.strokeColor, this.strokeStyle);
        }
        else
        {
            this.node.lineStyle(0);
        }
        this.node.beginFill(this.fillColor, 1);
        this.node.drawCircle(this.x, this.y, this.circleRadius);
        this.node.endFill();
    }

    /**
    * This method sets the x position if the displayObject
    * @param xVal x-position
    */
    public setX(xVal)
    {
        this.node.x = xVal;
    }

    public setY(yVal)
    {
        this.node.y = yVal;
    }

    public getX()
    {
        return this.node.x;
    }

    public getY()
    {
        return this.node.y;
    }

    public setXY(xVal, yVal)
    {
        this.setX(xVal);
        this.setY(yVal);
    }

    public setAlpha(val)
    {
        
        this.node.alpha = val;
    }

    public setWidth(pWidth)
    {
        this.node.width = pWidth;
    }

    public setHeight(pHeight)
    {
        this.node.height = pHeight;
    }



    /**
    * this sets the hitArea(clickable interactive area) with in the display object. 
    * The click events will be handled only when user clicks with in the hit area. 
    * This input parameters x, y , width and height acts as bounding box for the hit area.
    * @param x x coordinates for the hit area
    * @param y y coordinates for the hit area
    * @param w width for the hit area
    * @param h width for the hit area
    */

    public setHitAreaByRect(x:number=0, y:number = 0, w:number = 100, h:number = 100)
    {
        this.node.hitArea = new PIXI.Rectangle(x, y, w, h);
    }


    /**
    * this sets the a polygon as an hitArea(clickable interactive area) with in the display object. 
    * The click events will be handled only when user clicks with in the polygon - hit area. 
    * @param polygon  this can be any shape created in or using the displayObject(rectangle, circle) or PIXI 
    */

    public setHitAreaByPolygon(polygon)
    {
        this.node.hitArea = polygon;
    }

    /**
    * This makes the displayobject interactive by allowing to handle click and click callbacks
    * The click events will be handled only when user clicks with in the polygon - hit area. 
    * @param pval  can be true or false 
    */
    public clickable(pVal:boolean = false)
    {
        this.allowClick = pVal;
        this.node.interactive = pVal;
    }

    /**
    * This method scales the display object.
    * @param val degrees to rotate
    */
    public setRotation(val:number = 0)
    {
      
        this.node.rotation = val;
    }


    /**
    * This method scales the display object.
    * @param val degrees to rotate
    */
    public getRotation()
    {
        
        return this.node.rotation;
    }



    /**
    * This method scales the display object.
    * @param x X-axis scale value range from 0 to 1
    * @param y Y-axis scale value range from 0 to 1
    */
    public setScale(x:number = 1, y:number = 1)
    {
        if(arguments.length === 1)
        {
            this.node.scale.x = x;
            this.node.scale.y = x;
        }
        else if(arguments.length === 2)
        {
            this.node.scale.x = x;
            this.node.scale.y = y;
        }
        //this.node.scale = new PIXI.Point(x, y);
        
        //text.scale.y = scaleFactor;
    }

    /**
    * This method sets the anchor to the display object.
    * @param pVal value range between 0 to 1;
    */
    public setAnchor(xAnchor:number, yAnchor:number)
    {
        if(arguments.length === 2)
        {
            this.node.anchor.set(xAnchor, yAnchor );
        }
        else
        {
            this.node.anchor.set(xAnchor);
        }
        
    }

    /**
    * This method sets the cursor to Handcursor. This is used in alog with [[allowClick]] property to the display object.
    * @param pVal value range between 0 to 1;
    */
    public setHandCursor(pVal:number)
    {
        this.node.buttonMode = pval;
    }

    /**
    * This method sets the pivot point for the display object. This pivot point acts as key when transforming the DisplayObjects.
    * @param x X position of the pivot. The value range between 0 to 1 where 0 being left end and 1 being the right end;
    * @param y Y position of the pivot The value range between 0 to 1 where 0 being left end and 1 being the right end;* 
    */
    public setPivotByPoint(x:number = 0, y:number = 0)
    {
        //this.node.scale = new PIXI.Point(x, y);
        this.node.pivot =  new PIXI.Point(x, y);
        
        //text.scale.y = scaleFactor;
    }

    /**
    * This method sets the pivot point for the display object. This pivot point acts as key when transforming the DisplayObjects.
    * @param x X position of the pivot. The value range between 0 to 1 where 0 being left end and 1 being the right end;
    * @param y Y position of the pivot The value range between 0 to 1 where 0 being left end and 1 being the right end;* 
    */
   public setPivot(pstr="TOPLEFT")
   {
       //this.node.scale = new PIXI.Point(x, y);

       if(Array.isArray(pstr))
       {
            this.node.pivot.x = pstr[0];
            this.node.pivot.y = pstr[1];
       }
       else
       {
            if(pstr === "MIDDLE")
            {
                this.node.pivot.x =  this.node.width/2;
                this.node.pivot.y =  this.node.height/2;
            }
            else if(pstr === "TOPLEFT")
            {
                this.node.pivot.x =  0;
                this.node.pivot.y =  0;
            }
            else
            {
                this.node.pivot.x =  0;
                this.node.pivot.y =  0;
            }
       }
        
       
       
       //text.scale.y = scaleFactor;
   }

    /**
    * This method returns the internal core PIXI object(Sprite / Spine / Container) created with in the Display Object
    * 
    */
    public getNode()
    {
        if(this.node === null)
        {
            console.log("Node unavailable.............");
        }
        else
        {
            return this.node;
        }
        
    }

    /**
    * This method makes the display object visible on the stage
    * 
    */
    public show()
    {
        this.node.visible = true;
    }

    /**
    * This method makes the display object invisible on the stage
    * 
    */
    public hide()
    {
        this.node.visible = false;
    }

    /**
    * This method adds children to the display object
    * @param child this can be any type of display object.
    */
    public addChild(child)
    {
        this.node.addChild(child.node);
    }

    /**
    * This method adds children to the display object at specific index
    * @param child this can be any type of display object.
    */
    public addChildAt(child, index)
    {
        this.node.addChildAt(child.node, index);
    }

    /**
    * This method adds children to the display object
    * @param child this can be any type of display object.
    */
    public removeChild(child)
    {
        this.node.removeChild(child.node);
    }

    /**
    * This method kills the display object completely from the memory
    */
    public destroy()
    {
        this.node.destroy();
    }

    public onTickerUpdate()
    {
        console.log("Hello....");
    }

    public setTexture(texture)
    {
        console.log("Hello....");
    }
    
    /**
    * This method handles the chnages to be applied for the display object when there is a change in the orientation
    */
    protected onOrientationChange(this)
    {
        console.log("onOrientationChange Event fired.....");
        if(this.initData.lom)
        {
            let mergedLayoutData = {}
            let mainLayoutData = {}
            let orientationData = {};
            if(Resizer.CURRENT_ORIENTATION === "LANDSCAPE")
            {
                mainLayoutData = this.initData;
                orientationData = this.initData.lom.landscape;
            }
            else if(Resizer.CURRENT_ORIENTATION === "PORTRAIT")
            {
                mainLayoutData = this.initData;
                orientationData = this.initData.lom.portrait;
            }
            mergedLayoutData = {...mainLayoutData, ...orientationData};
            this.reApplyProperties(mergedLayoutData);
        }
    }
    
    /**
    * 
    * This method refresh the properties of the DisplayObject
    */

    public reApplyProperties(newData)
    {
        this.setXY(newData.x, newData.y);

        if(newData.width)
        {
            this.setWidth(newData.width);
        }
        
        if(newData.height)
        {
            this.setHeight(newData.height);
        }

        /*
        if(newData.visible === true)
        {
            this.show();
        }
        else if(newData.visible === false)
        {
            this.hide();
        }
        else
        {
            this.show();
        }*/
        

        // There is a possibility of chnaging the properties during runtime 
        // and player can change the orientatation at anypoint. 
        // We cant revert the coordintes to original state That s wrong.

        // Need to keep track of runtime changes and apply the latest runtime data specific to the orinetation

        //this.setAlpha(newData.alpha);
        this.setScale(newData.scale);
        //this.node.render
    }


    /**
    * This method attached event and call backs to the display object
    * See the [[Listener]] class for more details.
    */

    public addEventListener(eventName, callback)
    {
        
        if(Listener.EVENTS[eventName])
        {
            Listener.EVENTS[eventName].registerCallback(callback);
        }
        else
        {
            console.log(" *** "+ eventName + " Event not registered.....");
        }
        
    }

       

}


